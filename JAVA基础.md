## 了解过字节码的编译过程吗？


## 双亲委派模型中，从顶层到底层，都是哪些类加载器，分别加载哪些类？
*_相似问题：说说双亲委派模型？_*  
双亲委派的意思是如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。这里的双亲其实就指的是父类，没有mother。父类也不是我们平日所说的那种继承关系，只是调用逻辑是这样。
![15667232849231](media/15667232849231.jpeg)

双亲委派的作用：  
在Java中，对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性。因此，使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处：类随着它的类加载器一起具备了一种带有优先级的层次关系。

例如类java.lang.Object，它由启动类加载器加载。双亲委派模型保证任何类加载器收到的对java.lang.Object的加载请求，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。

一个符合规范的类加载器，应当仅覆写ClassLoader#findClass()，以支持自定义的类加载方式。不建议覆写ClassLoader#loadClass()（以使用默认的类加载逻辑，即双亲委派模型）；如果需要覆写，则不应该破坏双亲委派模型。不会出现相同全限定名的类被不同类加载器加载的问题，也就不会引起混乱了。


类加载器按从顶到底：  
启动类加载器(bootstrap classLoader，级别最高)  
扩展类加载器(extension)  
应用类加载器(Application)  
自定义类加载器(user ClassLoader);

（1）启动类加载器（Bootstrap ClassLoader）  
这个类加载器负责将存放在JAVA_HOME/lib下的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用。  
（2）扩展类加载器（Extension ClassLoader）  
这个加载器负责加载JAVA_HOME/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。  
（3）应用程序类加载器（Application ClassLoader）  
这个加载器是ClassLoader中getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（Classpath）上所指定的类库，可直接使用这个加载器，如果应用程序没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器

> [Java学习记录--委派模型与类加载器](https://cloud.tencent.com/developer/article/1347591)

## 有没有可能父类加载器和子类加载器，加载同一个类？如果加载同一个类，该使用哪一个类？
如果在双亲委派的模型，不可能同时加载到同一个类。如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一层次的加载器都是如此。因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。  

如果打破了双亲委派模型（不是强制性约束），确实可以加载同一个类。  

如果加载同一个类，那要根据当前线程上下文类加载器是哪个来确定使用了哪个类，如果是父类加载器则使用父类加载器加载的类，否则反之。

类加载过程：  
（1）通过findLoadedClass()，查看请求的类是否被加载过；  
（2）若没有加载，则调用父类加载器的loadClass()方法进行加载；  
（3）若父类加载器加载为空则用启动类加载器作为父类加载器；  
（4）如果父类加载失败，则抛出异常；  
（5）然后再调用自己的findClass()方法进行加载；  
（6）最后判断该类是否进行解析resolveClass()；  

> [细说JVM（类加载器）](https://zhuanlan.zhihu.com/p/41672523)

## 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破？
改变线程上下文类加载器。

>Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。

>这些 SPI 的接口由 Java 核心库来提供，而这些 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径（CLASSPATH）里。SPI接口中的代码经常需要加载具体的实现类。那么问题来了，SPI的接口是Java核心库的一部分，是由**启动类加载器(Bootstrap Classloader)来加载的；SPI的实现类是由系统类加载器(System ClassLoader)**来加载的。引导类加载器是无法找到 SPI 的实现类的，因为依照双亲委派模型，BootstrapClassloader无法委派AppClassLoader来加载类。

>而线程上下文类加载器破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器。JDBC加载实现类就是使用了
>```
>Class.forName(aDriver, true, ClassLoader.getSystemClassLoader());
>```
>ClassLoader.getSystemClassLoader方法无论何时均会返回ApplicationClassLoader。


> [真正理解线程上下文类加载器（多案例分析）](https://blog.csdn.net/yangcheng33/article/details/52631940)

## 讲讲JAVA的反射机制？

## 反射的原理，反射创建类实例的三种方式是什么？

## 反射中，Class.forName和ClassLoader区别？


## 如何实现两金额数据相加（最多小数点两位）?

## static有什么用途？（请至少说明两种）

## 全局变量和局部变量在内存中是否有区别？如果有，是什么区别？

## String类能被继承吗，为什么？

## 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序？

## ArrayList 和 Vector 的区别。

## JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计？
https://www.jianshu.com/p/f93912fec48b

## IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型？

## 描述动态代理的几种实现方式，分别说出相应的优缺点？

## 动态代理与cglib实现的区别？

## 为什么CGlib方式可以对接口实现代理？

## final的用途？

## 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣？

## 深拷贝和浅拷贝区别？

## error和exception的区别，CheckedException，RuntimeException的区别？

## 请列出5个运行时异常？

## 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么？

## 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法？

## 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题？

## 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决？

## 了解哪设计模式，举例说说在jdk源码哪些用到了你说的设计模式？